# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# DÃ©finition des Ã©tapes (stages) du pipeline CI/CD
stages:
  - build           # 0. Ã‰tape de build : construction de l'image Docker
  - test            # 1. Docker Compose et tests
  - deploy_preprod  # 2. DÃ©ploiement en prÃ©production
  - deploy_prod     # 3. DÃ©ploiement en production (branche main + dÃ©clenchement manuel)


# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# Ã‰tape de build
build:
  stage: build
  script:
    # Affichage du message de dÃ©but de build
    - echo "â†’ Etape de build"
    - echo "Registre cible = $CI_REGISTRY"
    
    # Ou suis je ?
    - pwd
    # Que contient le rÃ©pertoire ?
    - ls -la

    # Build de l'image Docker Ã  partir du Dockerfile et push vers le registre GitLab
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    - docker build -f Dockerfile -t $CI_REGISTRY_IMAGE:app-demo_cicd-v0.$CI_PIPELINE_IID .
    - docker push $CI_REGISTRY_IMAGE:app-demo_cicd-v0.$CI_PIPELINE_IID

    # Affichage du message de succÃ¨s avec l'ID du pipeline
    - echo "ğŸ“¦ Image construite"

  # RÃ¨gle : ce job s'exÃ©cute sur les branches develop et main
  rules:
  - if: '$CI_COMMIT_BRANCH == "develop"'
  - if: '$CI_COMMIT_BRANCH == "main"'

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸ§ª Ã‰tape de test
test:
  stage: test
  environment:
    name: test
  script:
    - echo "â†’ Etape de Test"

    ###############################################################################################
    # TEST 1 - Tests unitaires dans un conteneur dÃ©diÃ© avec pytest
    - echo "â†’ TEST 1 - Tests unitaires dans un conteneur dÃ©diÃ© avec pytest"

    # Construction de l'image depuis la racine du projet
    - docker build -t pytest-runner -f tests/Dockerfile .

    # ExÃ©cution du conteneur, suppression automatique aprÃ¨s exÃ©cution
    - docker run --rm pytest-runner

    ###############################################################################################
    # TEST 2 - Test de l'image Docker avec un conteneur isolÃ©
    - echo "â†’ TEST 1 - Test de l'image Docker"

    # Suppression d'un Ã©ventuel conteneur existant pour Ã©viter les conflits de nom
    - docker rm -f container-de-test || true

    # DÃ©marrage du conteneur (pas besoin de publier les ports ici)
    - docker run -d --name container-de-test $CI_REGISTRY_IMAGE:app-demo_cicd-v0.$CI_PIPELINE_IID

    # Pause pour laisser le serveur Flask dÃ©marrer
    - sleep 5

    # Test interne : curl exÃ©cutÃ© DANS le conteneur
    - |
      if docker exec container-de-test curl -sSf http://localhost:8080 > /dev/null; then
        echo "âœ… Test HTTP rÃ©ussi dans le conteneur"
      else
        echo "âŒ L'application ne rÃ©pond pas dans le conteneur" >&2
        exit 1
      fi

    # Nettoyage du conteneur de test aprÃ¨s le test
    - docker stop container-de-test
    - docker rm container-de-test

    ###############################################################################################
    # TEST 3 - Test d'intÃ©gration avec Docker Compose
    - echo "â†’ TEST 3 - Test d'intÃ©gration avec Docker Compose"

    # Connexion au GitLab Container Registry
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    # Pull de lâ€™image application si nÃ©cessaire (le fichier compose va le faire aussi)
    - docker pull $CI_REGISTRY_IMAGE:app-demo_cicd-v0.$CI_PIPELINE_IID

    # DÃ©finir le nom d'image utilisÃ© dans le compose
    - export APP_IMAGE="$CI_REGISTRY_IMAGE:app-demo_cicd-v0.$CI_PIPELINE_IID"
    # DÃ©finir le nom de l'app pour l'environnement de test
    - export APP_NAME="app_web_test"
    # DÃ©finir le port pour l'environnement de test
    - export APP_PORT="8888"
    # DÃ©finir le nom de la base redis pour l'environnement de test
    - export REDIS_NAME="redis_test"
    # DÃ©finir le port redis pour l'environnement de test
    - export REDIS_PORT="63790"

    # ArrÃªt des conteneurs existants pour lâ€™environnement courant
    - docker compose --project-name ${APP_ENV} -f docker-compose.yml down || true

    # Lancement de la stack isolÃ©e pour lâ€™environnement courant
    - docker compose --project-name ${APP_ENV} -f docker-compose.yml up -d

    # Pause pour laisser le service dÃ©marrer
    - sleep 5

    # Test interne : curl exÃ©cutÃ© DANS le conteneur aprÃ¨s Docker Compose
    - |
      echo "ğŸ” VÃ©rification du compteur de visites :"
      if docker exec app_web_test curl -s http://localhost:8080 | grep -E "<strong>Visites :</strong> *[0-9]+"; then
        echo "âœ… Liaison avec Redis : OK "
      else
        echo "âŒ Liaison avec Redis : NOK â†’ problÃ¨me potentiel avec Redis ou session Flask" >&2 
        docker logs app_web_test
        exit 1
      fi

    # RÃ¨gle : ce job s'exÃ©cute sur les branches develop et main
  rules:
   - if: '$CI_COMMIT_BRANCH == "develop"'
   - if: '$CI_COMMIT_BRANCH == "main"'

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸš§ DÃ©ploiement prÃ©production
deploy_preprod:
  stage: deploy_preprod
  environment:
    name: preprod
  script:
    - echo "â†’ DÃ©ploiement sur la prÃ©production"

    # Connexion au GitLab Container Registry
    - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
    # Pull de lâ€™image application si nÃ©cessaire (le fichier compose va le faire aussi)
    - docker pull $CI_REGISTRY_IMAGE:app-demo_cicd-v0.$CI_PIPELINE_IID

    # DÃ©finir le nom d'image utilisÃ© dans le compose
    - export APP_IMAGE="$CI_REGISTRY_IMAGE:app-demo_cicd-v0.$CI_PIPELINE_IID"
    # DÃ©finir le nom de l'app pour l'environnement de test
    - export APP_NAME="app_web_preprod"
    # DÃ©finir le port pour l'environnement de test
    - export APP_PORT="8880"
    # DÃ©finir le nom de la base redis pour l'environnement de test
    - export REDIS_NAME="redis_preprod"
    # DÃ©finir le port redis pour l'environnement de test
    - export REDIS_PORT="63791"

    # ArrÃªt des conteneurs existants pour lâ€™environnement courant
    - docker compose --project-name ${APP_ENV} -f docker-compose.yml down || true
    
    # Lancement de la stack isolÃ©e pour lâ€™environnement courant
    - docker compose --project-name ${APP_ENV} -f docker-compose.yml up -d

    # Re-tag de lâ€™image dÃ©ployÃ©e en prÃ©prod â†’ prod (versionning) + push vers le registre
    - docker tag $CI_REGISTRY_IMAGE:app-demo_cicd-v0.$CI_PIPELINE_IID $CI_REGISTRY_IMAGE:prod
    - docker tag $CI_REGISTRY_IMAGE:app-demo_cicd-v0.$CI_PIPELINE_IID $CI_REGISTRY_IMAGE:app-demo_cicd-prod-v0.$CI_PIPELINE_IID
    - docker push $CI_REGISTRY_IMAGE:prod
    - docker push $CI_REGISTRY_IMAGE:app-demo_cicd-prod-v0.$CI_PIPELINE_IID
    
  # RÃ¨gle : ce job s'exÃ©cute sur les branches develop et main
  rules:
  - if: '$CI_COMMIT_BRANCH == "develop"'
  - if: '$CI_COMMIT_BRANCH == "main"'

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ğŸš€ DÃ©ploiement production
deploy_prod:
  stage: deploy_prod
  environment:
    name: production
  script:
   - echo "â†’ DÃ©ploiement de l'image en production"

   # Connexion au GitLab Container Registry
   - docker login -u gitlab-ci-token -p $CI_JOB_TOKEN $CI_REGISTRY
   # Pull de lâ€™image application si nÃ©cessaire (le fichier compose va le faire aussi)
   - docker pull $CI_REGISTRY_IMAGE:prod

   # DÃ©finir le nom d'image utilisÃ© dans le compose
   - export APP_IMAGE="$CI_REGISTRY_IMAGE:app-demo_cicd-v0.$CI_PIPELINE_IID"
   # DÃ©finir le nom de l'app pour l'environnement de test
   - export APP_NAME="app_web_prod"
   # DÃ©finir le port pour l'environnement de test
   - export APP_PORT="8080"
  # DÃ©finir le nom de la base redis pour l'environnement de test
   - export REDIS_NAME="redis_prod"
  # DÃ©finir le port redis pour l'environnement de test
   - export REDIS_PORT="6379"
  
  # ArrÃªt des conteneurs existants pour lâ€™environnement courant
   - docker compose --project-name ${APP_ENV} -f docker-compose.yml down || true
  # Lancement de la stack isolÃ©e pour lâ€™environnement courant
   - docker compose --project-name ${APP_ENV} -f docker-compose.yml up -d

  # RÃ¨gle : uniquement sur la branche main, avec un dÃ©clenchement manuel dans l'interface GitLab 
  rules:
  - if: '$CI_COMMIT_BRANCH == "main"'
    when: manual
    allow_failure: false